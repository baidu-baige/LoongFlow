# Global directory configuration
workspace_path: "./output"

# Global LLM configuration(optional)
# If evaluator or other components don't have their own llm_config, this will be used
llm_config:
  url: "http://xxx/v1"
  api_key: "******"
  model: "deepseek-r1-250528"
  temperature: 0.8
  context_length: 128000
  max_tokens: 32768
  top_p: 1.0
  timeout: 1200

# ------------------------------------------------------------------------------
# Define all available components
# ------------------------------------------------------------------------------

# All available Planner configurations
planners:
  evolve_planner:
    # Planner-specific configurations (e.g., prompt templates, LLM used, etc.)
    react_max_steps: 10

# All available Executor configurations
executors:
  evolve_executor_react:
    # ExecutorReact-specific configurations
    parallel_candidates: 3
    max_rounds: 3
    react_max_steps: 15

  evolve_executor_chat:
    # ExecutorChat-specific configurations
    max_rounds: 3

  evolve_executor_fuse:
    # ExecutorFuse-specific configurations
    max_rounds: 3
    react_max_steps: 15
    score_threshold: 0.9

# All available Summarizer configurations
summarizers:
  evolve_summary:
    # Summarizer-specific configurations
    react_max_steps: 10
# ------------------------------------------------------------------------------
# Define configurations for the main evolution process
# ------------------------------------------------------------------------------
evolve:
  # Task description, is the core objective of the entire evolution process
  task: |
    Act as an expert software developer and inequality specialist specializing in creating step functions with certain properties.
    Your task is to generate the sequence of non-negative heights of a step functions, that minimizes the following evaluation function(keeping in mind that in this task we will want the returned value to be as small as possible, as we are improving the upper bound):
    
    <evaluation function>
    import numpy as np
    
    def evaluate_sequence(sequence: list[float]) -> float:
      """
      Evaluates a sequence of coefficients with enhanced security checks.
      Returns np.inf if the input is invalid.
      """
      # --- Security Checks ---
    
      # Verify that the input is a list
      if not isinstance(sequence, list):
        return np.inf
    
      # Reject empty lists
      if not sequence:
        return np.inf
    
      # Check each element in the list for validity
      for x in sequence:
        # Reject boolean types (as they are a subclass of int) and
        # any other non-integer/non-float types (like strings or complex numbers).
        if isinstance(x, bool) or not isinstance(x, (int, float)):
            return np.inf
    
        # Reject Not-a-Number (NaN) and infinity values.
        if np.isnan(x) or np.isinf(x):
            return np.inf
    
      # Convert all elements to float for consistency
      sequence = [float(x) for x in sequence]
    
      # Protect against negative numbers
      sequence = [max(0, x) for x in sequence]
    
      # Protect against numbers that are too large
      sequence = [min(1000.0, x) for x in sequence]
    
      n = len(sequence)
      b_sequence = np.convolve(sequence, sequence)
      max_b = max(b_sequence)
      sum_a = np.sum(sequence)
    
      # Protect against the case where the sum is too close to zero
      if sum_a < 0.01:
        return np.inf
    
      return float(2 * n * max_b / (sum_a**2))
    </evaluation function>
    
    Your task is to write the search function run_search_for_best_sequence() that searches for the best sequence of coefficients. Your function will have 1000 seconds to run, and after that it has to have returned the best sequence it found. If after 1000 seconds it has not returned anything, it will be terminated with negative infinity points. All numbers in your sequence have to be positive or zero.
    Currently, The step function run_search_for_best_sequence() has been found with 600 equally-spaced intervals on [-1/4, 1/4] that gives a better upper bound <= 1.5053. You should try to improve this upper bound, find a smaller value.
    You may code up any search method you want, but you must have to code up the run_search_for_best_sequence() function and the evaluate_sequence() function in your result, since you can use the evaluate_sequence() function to evaluate the run_search_for_best_sequence() function as many times as you want.
    
    Your solution should be written in Python.
    
    You got this! I believe in you!!!

  # Name of the component selected for current run
  planner_name: "evolve_planner"
  executor_name: "evolve_executor_fuse"
  summary_name: "evolve_summary"

  # Core parameters of the evolution process
  max_iterations: 1000
  target_score: 1.0
  concurrency: 3

  # Evaluator configurations
  evaluator:
    timeout: 1200


  # Database configurations
  database:
    storage_type: "in_memory"
    num_islands: 3
    population_size: 100
    checkpoint_interval: 5
    # If sampling_weight_power < 1, sampling weight has a weak effect
    sampling_weight_power: 1

