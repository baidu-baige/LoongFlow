# Global directory configurations
workspace_path: "./output"

# Global LLM configuration (optional)
# If evaluator or other components do not have their own llm_config, this configuration will be used
llm_config:
  url: "https://xxxxxx/v1"
  api_key: "******"
  model: "openai/gemini-3-pro-preview"
  temperature: 0.8
  context_length: 128000
  max_tokens: 32768
  top_p: 1.0
  timeout: 1200
  # Price per 1k tokens
  prompt_token_price: 0.008
  # Price per 1k tokens
  completion_token_price: 0.048

# ------------------------------------------------------------------------------
# Define the configuration for all available components
# ------------------------------------------------------------------------------

# All available Configuration for Planner
planners:
  evolve_planner:
    # Planner's specific configuration, such as prompt templates, used LLM, etc.
    react_max_steps: 10

# All available Configuration for Executor
executors:
  evolve_executor_react:
    # ExecutorReact's specific configuration
    parallel_candidates: 3
    max_rounds: 3
    react_max_steps: 15

  evolve_executor_chat:
    # ExecutorChat's specific configuration
    max_rounds: 3

  evolve_executor_fuse:
    # ExecutorFuse's specific configuration
    max_rounds: 3
    react_max_steps: 15
    score_threshold: 0.7

# All available Summarizer configuration
summarizers:
  evolve_summary:
    # Summarizer's specific configuration
    react_max_steps: 10
# ------------------------------------------------------------------------------
# Define the main evolution process configuration
# ------------------------------------------------------------------------------
evolve:
  # Task description, is the core objective of the entire evolution process
  task: |
    # An uncertainty inequality Problem
    Given a function  ğ‘“:â„â†’â„ , define the Fourier transform  ğ‘“Ë†(ğœ‰):=âˆ«â„ğ‘“(ğ‘¥)ğ‘’âˆ’2ğœ‹ğ‘–ğ‘¥ğœ‰ ğ‘‘ğ‘¥  and
      ğ´(ğ‘“):=inf{ğ‘Ÿ>0:ğ‘“(ğ‘¥)â‰¥0 for all |ğ‘¥|â‰¥ğ‘Ÿ}. 
    Let  ğ¶4  be the largest constant satisfying
      ğ´(ğ‘“)ğ´(ğ‘“Ë†)â‰¥ğ¶4 
    for all even  ğ‘“  with  max(ğ‘“(0),ğ‘“Ë†(0))<0 . It is known that
      0.2025 â‰¤ ğ¶4 â‰¤ 0.3523; 
    
    AlphaEvolve improved the upper bound to  ğ¶4 â‰¤ 0.3521  with a similar linear combination as in GonÃ§alves et al. (2017) but with refined constants.
    
    First, following the method in GonÃ§alves et al. (2017), we consider test functions of the form  ğ‘“(ğ‘¥)=ğ‘ƒ(ğ‘¥)ğ‘’âˆ’ğœ‹ğ‘¥2 , where  ğ‘ƒ(ğ‘¥)  is an even polynomial. For this form, the Fourier transform  ğ‘“Ì‚ (ğœ‰)  has the structure  ğ‘ƒ(ğœ‰)ğ‘’âˆ’ğœ‹ğœ‰2 , which implies  ğ´(ğ‘“)=ğ´(ğ‘“Ì‚ )  is the largest positive root of  ğ‘ƒ(ğ‘¥)  (for functions that are positive for large  |ğ‘¥| ). The inequality then becomes  ğ¶4â‰¤(ğ´(ğ‘“))2 .
    
    The polynomial  ğ‘ƒ(ğ‘¥)  is chosen as a linear combination of Hermite polynomials of even order  ğ»4ğ‘˜(ğ‘¥) , specifically  ğ‘ƒ(ğ‘¥)=âˆ‘ğ‘šğ‘˜=0ğ‘ğ‘˜ğ»4ğ‘˜(ğ‘¥) . The goal is to find coefficients  ğ‘ğ‘˜  that minimize the largest positive root of  ğ‘ƒ(ğ‘¥)  while satisfying certain conditions on  ğ‘ƒ(ğ‘¥)  (related to the  ğ‘“(0)<0  condition and  ğ‘ƒ(ğ‘¥)>0  for large  |ğ‘¥| ). In the implementation below, the polynomial  ğ‘ƒ(ğ‘¥)  is constructed with the technical constraint  ğ‘ƒ(0)=0 , meaning  ğ‘ƒ(ğ‘¥)  has a factor of  ğ‘¥2 . The largest positive root of  ğ‘ƒ(ğ‘¥)  is then the largest positive root of  ğ‘ƒ(ğ‘¥)/ğ‘¥2 . The upper bound on  ğ¶4  is given by this largest root squared, divided by  2ğœ‹ .
    
    AlphaEvolve found the coefficients ( ğ‘0 ,  ğ‘1 ,  ğ‘2 ) defining a polynomial  ğ‘ƒ(ğ‘¥)=ğ‘0ğ»0(ğ‘¥)+ğ‘1ğ»4(ğ‘¥)+ğ‘2ğ»8(ğ‘¥)  that provides an improved upper bound for  ğ¶4 .

    Your task is to find the coefficients ( ğ‘0 ,  ğ‘1 ,  ğ‘2 ), and I'll use the verify_hermite_combination function to verify its validity, and then use the valid coefficients to calculate the upper_bound. The goal is to find a better upper_bound <= 0.3521.

    <verify_hermite_combination>
    def verify_hermite_combination(coeffs: np.ndarray) -> sympy.Expr:
      """Computes the Hermite combination for given coefficients."""
      m = len(coeffs)
      rational_coeffs = [sympy.Rational(c) for c in coeffs]
      degrees = np.arange(0, 4 * m + 4, 4)
      x = sympy.symbols('x')
      hps = [
          sympy.polys.orthopolys.hermite_poly(n=i, x=x, polys=False)
          for i in degrees
      ]
    
      # All but the last coefficient.
      partial_fn: sympy.Expr = sum(
          rational_coeffs[i] * hps[i] for i in range(len(rational_coeffs))
      )
    
      # Impose the condition that the root at 0 should be 0.
      a = hps[-1].subs(x, 0)
      b = -partial_fn.subs(x, 0)
      last_coeff = b / a
      rational_coeffs.append(sympy.Rational(last_coeff))
    
      res_fn = sum(rational_coeffs[i] * hps[i] for i in range(len(rational_coeffs)))
    
      if sympy.limit(res_fn, x, sympy.oo) < 0:
        res_fn = -res_fn
    
      x = sympy.symbols('x')
      # Check the value at 0 is 0.
      value_at_0 = res_fn.subs(x, 0)
      assert value_at_0 == 0, f'The value at 0 is {value_at_0} != 0.'
      assert sympy.limit(res_fn, x, sympy.oo) > 0, 'Limit at infty is not positive.'
    </verify_hermite_combination>

    Requirement:
    1. Fully implement the find_coefficients function. The return result of coefficients needs to be able to pass the verification of the verify_hermite_combination function.
    2. Do not rewrite the verify_hermite_combination functions. Keep it unchanged.
    3. Optimize the algorithm to the extreme, striving to raise upper_bound <= 0.3521.

    Your solution should be written in Python.
    
    You got this! I believe in you!!!

  # Name of the component selected for current run
  planner_name: "evolve_planner"
  executor_name: "evolve_executor_fuse"
  summary_name: "evolve_summary"

  # Core parameters for the evolution process
  max_iterations: 1000
  target_score: 1.0
  concurrency: 3

  # Evaluator parameters
  evaluator:
    timeout: 1800


  # Database parameters
  database:
    storage_type: "in_memory"
    num_islands: 3
    population_size: 100
    checkpoint_interval: 5
    # If sampling_weight_power < 1, sampling weight has a weak effect
    sampling_weight_power: 1

